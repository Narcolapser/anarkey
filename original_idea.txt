I want to cover here the specific ideas that I have come up with for creating a multi-person password manager, while a lot could be done these core ideas represent the key problems and their solutions.

The primary issue with making a multi-person password database is how do you control security on a password when there is no third party to be the authority granting person. With the third party you get the corporate solution which is easy to do: There is a central password database and every person has an account on it. People’s access it controlled by simply granting permission. When that user asks for permission to open a password the system checks and if the person has access it gives it to them.

With a standalone system you don’t have a central control like that. When the user tries for a password they are the only ones who get to say they have access or not, so you must secure the password another way. Enter public-private key cryptography.

My plan is to have each password have it’s own public-private key set. When Bob makes a new password that he wants to share with Alice, so he encrypts the password with the password’s private key and shares the public key with Alice. I’ll explain how in a minute. 

Each user would have their own keychain which would house the public keys to all the passwords that they have access to. This keychain would be secured with a public private key pair. The private key for the key chain would be secured by password or other mechanisms. So Bob would unlock his private key which he would then use to unlock his keychain. 

Because the keychains are encrypted themselves it is impossible for Bob to put a key onto Alice’s keychain. So instead Bob will place the key in Alice’s “inbox”. To do this Bob need’s Alice’s public key, which since we are dealing with a local database and not a networked one, is readily available. Bob encrypts the public key for the password with his private key, then he encrypts the result with Alice’s public key. Then he places it in Alice’s inbox. 

This is necessary because they share this database with Carol and Bob did not intend to share this password with Carol. If he left the password unencrypted in Alice’s inbox, Carol could see the password. By encrypting it with Alice’s public key Bob verifies that only Alice can read it. However, if Carol had access to this password and was feeling malicious she could theoretically deny Alice access by encrypting the public key with Alice’s key and find the byte string that matches in Alice’s inbox and delete it. So by encrypting the password with Bob’s private key then Alice’s public key, it makes a unique byte string that can’t be simply deleted. Of course this does not protect against truly malicious people who would delete your entire keychain, don’t share a password database with them.

To further secure the key, once Alice logs into the database she can decrypt the waiting passwords and insert them into her keychain with the rest so that there aren’t any keys stored separately. This is entirely an un-necessary step and it’s utility would entirely depend on how the software decides to store the password information on disk and in memory. Now we have a system where passwords can be shared securely between Alice, Bob, and Carol with strict access control.

Should you update any sensitive information on a password (username, password, attributes, etc. Anything that isn’t metadata like it’s icon), a new key pair will be made. Stored in the newly encrypted password would be the public key to the previous historical entry on this password. If a password has been compromised or it’s public key has been compromised you should create a new version of the password which will result in a new key pair which will re-secure it. 

One last feature that would be necessary. Stored in a user’s keychain with the password’s public key would be a hash for the password. While the private key for a password is never supposed to be stored, it could be in theory by the person who made the password. To prevent that person from making changes without it being clear that they have it would be necessary to distribute a hash of the password entry when it is created. This would be distributed with the public key for the password. Having this hash Alice will be able to know if Bob has changed the value of the password without creating a new entry which would make it clear that he has. 

